name: Production Monitoring & Health Checks

on:
  schedule:
    - cron: '*/15 * * * *' # Every 15 minutes
  workflow_dispatch:
  deployment_status:

env:
  FRONTEND_URL: 'https://idabaguspurwa.com'
  BACKEND_URL: 'https://events-backend.fly.dev'

jobs:
  health-check:
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Check Frontend Health
      id: frontend
      run: |
        response=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.FRONTEND_URL }}" || echo "000")
        if [ "$response" = "200" ]; then
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo "‚úÖ Frontend is healthy (HTTP $response)"
        else
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo "‚ùå Frontend is unhealthy (HTTP $response)"
          exit 1
        fi
    
    - name: Check Backend Health
      id: backend
      run: |
        response=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.BACKEND_URL }}" || echo "000")
        if [ "$response" = "200" ]; then
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo "‚úÖ Backend is healthy (HTTP $response)"
        else
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo "‚ùå Backend is unhealthy (HTTP $response)"
          exit 1
        fi
    
    - name: Test WebSocket Connection
      id: websocket
      run: |
        # Install wscat for WebSocket testing
        npm install -g wscat
        
        # Test WebSocket connection with timeout
        timeout 10s wscat -c "wss://events-backend.fly.dev/ws/github-events" --execute "ping" > /dev/null 2>&1
        if [ $? -eq 0 ]; then
          echo "status=healthy" >> $GITHUB_OUTPUT
          echo "‚úÖ WebSocket connection is healthy"
        else
          echo "status=unhealthy" >> $GITHUB_OUTPUT
          echo "‚ùå WebSocket connection failed"
          exit 1
        fi
    
    - name: Check SSL Certificates
      run: |
        echo "Checking SSL certificate for frontend..."
        openssl s_client -connect idabaguspurwa.com:443 -servername idabaguspurwa.com < /dev/null 2>/dev/null | openssl x509 -noout -dates
        
        echo "Checking SSL certificate for backend..."
        openssl s_client -connect events-backend.fly.dev:443 -servername events-backend.fly.dev < /dev/null 2>/dev/null | openssl x509 -noout -dates
    
    - name: Performance Check
      run: |
        echo "Testing frontend response time..."
        time_taken=$(curl -o /dev/null -s -w "%{time_total}" "${{ env.FRONTEND_URL }}")
        echo "Frontend response time: ${time_taken}s"
        
        # Alert if response time > 3 seconds
        if (( $(echo "$time_taken > 3" | bc -l) )); then
          echo "‚ö†Ô∏è Frontend response time is slow: ${time_taken}s"
        fi
        
        echo "Testing backend response time..."
        time_taken=$(curl -o /dev/null -s -w "%{time_total}" "${{ env.BACKEND_URL }}")
        echo "Backend response time: ${time_taken}s"
        
        if (( $(echo "$time_taken > 2" | bc -l) )); then
          echo "‚ö†Ô∏è Backend response time is slow: ${time_taken}s"
        fi
    
    outputs:
      frontend_status: ${{ steps.frontend.outputs.status }}
      backend_status: ${{ steps.backend.outputs.status }}
      websocket_status: ${{ steps.websocket.outputs.status }}

  notify-failure:
    runs-on: ubuntu-latest
    needs: health-check
    if: failure()
    
    steps:
    - name: Create Issue on Failure
      uses: actions/github-script@v7
      with:
        script: |
          const now = new Date().toISOString();
          const title = `üö® Production Health Check Failed - ${now}`;
          
          const body = `## Production Service Health Check Failed
          
          **Time**: ${now}
          **Workflow**: ${{ github.workflow }}
          **Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          ### Status Summary
          - Frontend (${{ env.FRONTEND_URL }}): ${{ needs.health-check.outputs.frontend_status || 'failed' }}
          - Backend (${{ env.BACKEND_URL }}): ${{ needs.health-check.outputs.backend_status || 'failed' }}
          - WebSocket: ${{ needs.health-check.outputs.websocket_status || 'failed' }}
          
          ### Next Steps
          1. Check service logs
          2. Verify deployment status
          3. Check external dependencies
          4. Consider rollback if necessary
          
          ### Auto-generated by GitHub Actions Monitoring
          This issue was automatically created by the monitoring workflow.
          `;
          
          // Check if similar issue already exists
          const existingIssues = await github.rest.issues.listForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            state: 'open',
            labels: ['monitoring', 'production', 'health-check']
          });
          
          if (existingIssues.data.length === 0) {
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['bug', 'monitoring', 'production', 'health-check', 'high-priority']
            });
          }

  deployment-notification:
    runs-on: ubuntu-latest
    if: github.event_name == 'deployment_status'
    
    steps:
    - name: Notify Deployment Status
      uses: actions/github-script@v7
      with:
        script: |
          const deployment = context.payload.deployment;
          const deploymentStatus = context.payload.deployment_status;
          
          let emoji = 'üîÑ';
          let status = deploymentStatus.state;
          
          if (status === 'success') emoji = '‚úÖ';
          else if (status === 'failure') emoji = '‚ùå';
          else if (status === 'error') emoji = 'üö®';
          else if (status === 'pending') emoji = '‚è≥';
          
          const message = `${emoji} **Deployment ${status}**
          
          **Environment**: ${deployment.environment}
          **SHA**: ${deployment.sha}
          **URL**: ${deploymentStatus.target_url || 'N/A'}
          
          ${deploymentStatus.description || 'No description provided'}`;
          
          // Comment on the latest commit
          await github.rest.repos.createCommitComment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            commit_sha: deployment.sha,
            body: message
          });

  uptime-report:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' && github.event.schedule == '0 9 * * 1' # Weekly on Monday at 9 AM UTC
    
    steps:
    - name: Generate Weekly Uptime Report
      uses: actions/github-script@v7
      with:
        script: |
          // This is a simplified uptime report
          // In practice, you'd integrate with monitoring services like Pingdom, UptimeRobot, etc.
          
          const now = new Date();
          const weekAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000);
          
          const report = `# üìä Weekly Uptime Report
          
          **Period**: ${weekAgo.toDateString()} - ${now.toDateString()}
          
          ## Service Status
          - üåê **Frontend**: idabaguspurwa.com
          - üîß **Backend**: events-backend.fly.dev
          - üîå **WebSocket**: Real-time data streaming
          
          ## Key Metrics
          - Monitoring frequency: Every 15 minutes
          - Total checks this week: ~672 per service
          - Health check workflow: [View latest run](${{ github.server_url }}/${{ github.repository }}/actions/workflows/monitoring.yml)
          
          ## Notes
          - All monitoring is automated via GitHub Actions
          - Issues are automatically created for failures
          - SSL certificates are monitored daily
          
          *Report generated automatically by GitHub Actions*`;
          
          // Create or update a discussion/issue for the weekly report
          await github.rest.issues.create({
            owner: context.repo.owner,
            repo: context.repo.repo,
            title: `Weekly Uptime Report - ${now.toDateString()}`,
            body: report,
            labels: ['monitoring', 'report', 'weekly']
          });